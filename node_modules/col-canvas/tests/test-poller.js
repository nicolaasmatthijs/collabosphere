/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var assert = require('assert');

var ActivitiesDefault = require('col-activities/lib/default');
var CanvasPoller = require('col-canvas/lib/poller');
var DB = require('col-core/lib/db');
var TestsUtil = require('col-tests/lib/util');
var UsersTestUtil = require('col-users/tests/util');

var CanvasAssignment = require('./model').CanvasAssignment;
var CanvasDiscussion = require('./model').CanvasDiscussion;
var CanvasDiscussionEntry = require('./model').CanvasDiscussionEntry;
var CanvasFile = require('./model').CanvasFile;
var CanvasSubmission = require('./model').CanvasSubmission;
var CanvasTestsUtil = require('./util');
var CanvasUser = require('./model').CanvasUser;

describe('Canvas poller', function() {

  /**
   * Get a course object given a Canvas course id
   *
   * @param  {Number}           canvasCourseId      The id of the course in Canvas
   * @param  {Function}         callback            Invoked when the course has been retrieved
   * @param  {Course}           callback.course     The course object
   * @throws {AssertionError}                       Error thrown when an assertion failed
   */
  var getCourse = function(canvasCourseId, callback) {
    var options = {
      'where': {
        'canvas_course_id': canvasCourseId
      },
      'include': [{
        'model': DB.Canvas,
        'as': 'canvas'
      }]
    };
    DB.Course.findOne(options).complete(function(err, course) {
      assert.ok(!err);
      assert.ok(course);
      return callback(course);
    });
  };

  describe('Users', function() {

    /**
     * Test that verifies that the Canvas poller creates a record for users that haven't launched a tool yet
     */
    it('creates records for users that have not launched a tool yet', function(callback) {
      // Generate a test course
      TestsUtil.getAssetLibraryClient(null, null, null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(course) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = [new CanvasUser('Jack McJackerson')];
          CanvasTestsUtil.mockPollingRequests(course, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(course, function(err) {
            assert.ok(!err);

            // The poller should've created a user account for Jack
            DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
              assert.ok(!err);
              assert.strictEqual(users.length, 2);
              assert.ok(_.find(users, {'canvas_full_name': 'Jack McJackerson'}));

              // Verify a subsequent run won't create another user record
              CanvasTestsUtil.mockPollingRequests(course, mockedCanvasUsers);
              CanvasPoller.handleCourse(course, function(err) {
                assert.ok(!err);

                // The poller should've created a user account for Jack
                DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                  assert.ok(!err);
                  assert.strictEqual(users.length, 2);
                  assert.ok(_.find(users, {'canvas_full_name': 'Jack McJackerson'}));
                  return callback();
                });
              });
            });
          });
        });
      });
    });
  });

  describe('Assignments', function() {

    /**
     * Test that verifies that activities are created for submissions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will make submissions
      TestsUtil.getAssetLibraryClient(null, null, null, function(clientA, course, userA) {
        TestsUtil.getAssetLibraryClient(null, course, null, function(clientB, course, userB) {
          TestsUtil.getAssetLibraryClient(null, course, null, function(clientC, course, userC) {
            TestsUtil.getAssetLibraryClient(null, course, null, function(clientD, course, userD) {

              // Get the actual course object so we can pass it into the poller
              getCourse(course.id, function(course) {

                // Poll the canvas API but don't return the assignment just yet
                CanvasTestsUtil.mockPollingRequests(course, [], [], []);
                CanvasPoller.handleCourse(course, function(err) {
                  assert.ok(!err);

                  // Get all the users, they should all have 0 points
                  DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                    assert.ok(!err);
                    assert.strictEqual(users.length, 4);
                    _.each(users, function(user) {
                      assert.strictEqual(user.points, 0);
                    });

                    // Poll the Canvas API and return an assignment without any submissions
                    var assignments = [
                      new CanvasAssignment(course.id)
                    ];
                    CanvasTestsUtil.mockPollingRequests(course, [], assignments, []);
                    CanvasPoller.handleCourse(course, function(err) {
                      assert.ok(!err);

                      // All the users who made a submission should've received points
                      DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                        assert.ok(!err);
                        assert.strictEqual(users.length, 4);
                        _.each(users, function(user) {
                          assert.strictEqual(user.points, 0);
                        });

                        // Poll the Canvas API and return an assignment with a few submissions
                        var assignments = [
                          new CanvasAssignment(course.id, [
                            new CanvasSubmission(userA.id, 'online_url', 'http://www.google.com'),
                            new CanvasSubmission(userB.id, 'online_text_entry', null, null, 'Here is my essay on ...'),
                            new CanvasSubmission(userC.id, 'online_upload', null, [
                              new CanvasFile('image/jpeg', 'Oh noes', 'ohnoes.jpg')
                            ])
                          ])
                        ];
                        CanvasTestsUtil.mockPollingRequests(course, [], assignments, []);
                        CanvasPoller.handleCourse(course, function(err) {
                          assert.ok(!err);

                          // All the users who made a submission should've received points
                          DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                            assert.ok(!err);
                            assert.strictEqual(users.length, 4);

                            var expectedPoints = _.find(ActivitiesDefault, {'type': 'submit_assignment'}).points;
                            assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, expectedPoints);
                            assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, expectedPoints);
                            assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, expectedPoints);

                            // Users without submissions don't get any points
                            assert.strictEqual(_.find(users, {'canvas_user_id': userD.id}).points, 0);

                            // Subsequent polls should not result in new activities
                            CanvasTestsUtil.mockPollingRequests(course, [], assignments, []);
                            CanvasPoller.handleCourse(course, function(err) {
                              assert.ok(!err);
                              DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                                assert.ok(!err);
                                assert.strictEqual(users.length, 4);
                                assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, expectedPoints);
                                assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, expectedPoints);
                                assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, expectedPoints);
                                assert.strictEqual(_.find(users, {'canvas_user_id': userD.id}).points, 0);

                                return callback();
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });

  describe('Discussions', function() {

    /**
     * Test that verifies that activities are created for discussions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will make submissions
      TestsUtil.getAssetLibraryClient(null, null, null, function(clientA, course, userA) {
        TestsUtil.getAssetLibraryClient(null, course, null, function(clientB, course, userB) {
          TestsUtil.getAssetLibraryClient(null, course, null, function(clientC, course, userC) {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(course) {

              // Poll the canvas API but don't return a discussion just yet
              CanvasTestsUtil.mockPollingRequests(course, [], [], []);
              CanvasPoller.handleCourse(course, function(err) {
                assert.ok(!err);

                // Get all the users, they should all have 0 points
                DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                  assert.ok(!err);
                  assert.strictEqual(users.length, 3);
                  _.each(users, function(user) {
                    assert.strictEqual(user.points, 0);
                  });

                  // Poll the Canvas API and return the discussion
                  var discussion = new CanvasDiscussion(userA);
                  CanvasTestsUtil.mockPollingRequests(course, [], [], [discussion]);
                  CanvasPoller.handleCourse(course, function(err) {
                    assert.ok(!err);

                    var topicPoints = _.find(ActivitiesDefault, {'type': 'discussion_topic'}).points;
                    var entryPoints = _.find(ActivitiesDefault, {'type': 'discussion_entry'}).points;
                    var entryGetReplyPoints = _.find(ActivitiesDefault, {'type': 'discussion_entry_get_reply'}).points;

                    // The user who created the discussion should've received points
                    DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                      assert.ok(!err);
                      assert.strictEqual(users.length, 3);

                      assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, topicPoints);
                      assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, 0);
                      assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, 0);

                      // Subsequent polls should not result in new activities
                      CanvasTestsUtil.mockPollingRequests(course, [], [], [discussion]);
                      CanvasPoller.handleCourse(course, function(err) {
                        assert.ok(!err);
                        DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                          assert.ok(!err);
                          assert.strictEqual(users.length, 3);
                          assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, topicPoints);
                          assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, 0);
                          assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, 0);

                          // Add an entry to a discussion
                          discussion.addEntry(new CanvasDiscussionEntry(userB));
                          CanvasTestsUtil.mockPollingRequests(course, [], [], [discussion]);
                          CanvasPoller.handleCourse(course, function(err) {
                            assert.ok(!err);

                            // The user who created the discussion should've received points
                            DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                              assert.ok(!err);
                              assert.strictEqual(users.length, 3);

                              assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, topicPoints);
                              assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, entryPoints);
                              assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, 0);

                              // Reply to an entry
                              discussion.addEntry(new CanvasDiscussionEntry(userC, discussion.getEntries()[0].id));
                              CanvasTestsUtil.mockPollingRequests(course, [], [], [discussion]);
                              CanvasPoller.handleCourse(course, function(err) {
                                assert.ok(!err);

                                // The user who created the discussion should've received points
                                DB.User.findAll({'where': {'course_id': course.id}}).complete(function(err, users) {
                                  assert.ok(!err);
                                  assert.strictEqual(users.length, 3);

                                  assert.strictEqual(_.find(users, {'canvas_user_id': userA.id}).points, topicPoints);
                                  assert.strictEqual(_.find(users, {'canvas_user_id': userB.id}).points, entryPoints + entryGetReplyPoints);
                                  assert.strictEqual(_.find(users, {'canvas_user_id': userC.id}).points, entryPoints);

                                  return callback();
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
